---
title: "Untitled"
author: "Rodrigo"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r, cache=FALSE, message=FALSE, warning=FALSE, results='hide'}

if (!require("pacman")) install.packages("pacman")

pacotes_cran <- c(
  "devtools",
  "tidyverse",    # Coleção de pacotes para manipulação e visualização de dados (ggplot2, dplyr, etc.)
  "vcfR",         # Para ler e manipular arquivos VCF (seus dados genéticos)
  "CMplot",       # Para criar gráficos de Manhattan e outros gráficos genômicos
  "parallel",     # Para executar tarefas em paralelo e acelerar o processamento
  "ggpubr",       # Facilita a criação de gráficos prontos para publicação
  "ggh4x",        # Extensões para o ggplot2
  "grid",          # Funções gráficas de baixo nível
  "circlize",
  "onemap"
)
# formato "nome_do_usuario/nome_do_repositorio".
pacotes_github <- c(
  "dcgerard/segtest@higher", # Pacote para testes de segregação. A parte "@higher" instala uma versão específica.
  "dcgerard/updog",          # Para genotipagem de poliploides
  "dcgerard/ldsep",          # Para análise de desequilíbrio de ligação
  "jendelman/GWASpoly",      # Para estudos de associação genômica ampla (GWAS) em poliploides
  "mmollina/mappoly"         # Para construção de mapas de ligação em poliploides
)

pacman::p_load(char = pacotes_cran)
pacman::p_load_gh(char = pacotes_github)

rm(list = ls())
gc(verbose = FALSE)
```

```{r, cache=FALSE}

# --- VERSÃO FINAL E DEFINITIVA (v11) ---

# Carregando os pacotes necessários
library(vcfR)
library(ape)
library(stringr)
library(ggplot2)

# --- PASSO 1: Carregar os arquivos ---
vcf_Cc <- vcfR::read.vcfR("Cc_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf")
gff <- ape::read.gff("genomic.gff")
dna <- ape::read.dna("GCF_036785885.1_Coffea_Arabica_ET-39_HiFi_genomic.fna", format = "fasta")

# --- PASSO 2: Criar a tabela de mapeamento ---
region_info <- gff[gff$type == "region", ]
bio_names <- sapply(as.character(region_info$attributes), function(attr_string) {
  fields <- strsplit(attr_string, ";")[[1]]
  chrom_field <- grep("chromosome=", fields, value = TRUE)
  if (length(chrom_field) == 0) return(NA)
  return(strsplit(chrom_field, "=")[[1]][2])
})
chrom_map <- data.frame(
  ncbi_id = as.character(region_info$seqid),
  bio_name = bio_names
)
chrom_map <- chrom_map[chrom_map$bio_name != "Unknown", ]
chrom_map <- na.omit(chrom_map)

# --- PASSO 3: PADRONIZAR NOMES DE CROMOSSOMOS EM TODOS OS OBJETOS ---

print("---- PASSO 3: Padronizando nomes de cromossomos... ----")

# 3.1 Padronizar GFF: Substituir 'NC_...' por '1c', '1e', etc.
gff_chroms <- as.character(gff$seqid)
gff$seqid <- chrom_map$bio_name[match(gff_chroms, chrom_map$ncbi_id)]

# 3.2 Padronizar DNA: Substituir 'NC_...' por '1c', '1e', etc.
dna_ids <- word(names(dna), 1) 
names(dna) <- chrom_map$bio_name[match(dna_ids, chrom_map$ncbi_id)]

# 3.3 Padronizar VCF: Remover o prefixo 'chr' para ter '1c', '1e', etc.
vcf_Cc@fix[, 'CHROM'] <- gsub("chr", "", getCHROM(vcf_Cc))

# 3.4 Limpeza final: Remover qualquer elemento que não foi padronizado (virou NA)
gff <- gff[!is.na(gff$seqid), ]
dna <- dna[!is.na(names(dna))]
vcf_Cc <- vcf_Cc[!is.na(getCHROM(vcf_Cc)), ]

print("Nomes padronizados. Verificando o número de variantes restantes no VCF:")
print(nrow(vcf_Cc@fix))


# --- PASSO 4: Criar o objeto ChromR e plotar ---

print("---- PASSO 4: Preparando para criar o objeto chromR... ----")

# Selecionar a sequência de DNA para o cromossomo '1c'
dna_1c <- dna[names(dna) == '1c']

# Criar o objeto.
chrom <- create.chromR(name = '1c', vcf = vcf_Cc, seq = dna_1c, ann = gff)
png(filename = "grafico_qc_cromossomo_1c.png", width = 800, height = 1000)

# 2. Executa o comando para criar o gráfico.
chromoqc(chrom, dp.alpha = 50)

# 3. CRUCIAL: Fecha o dispositivo. Isso finaliza e salva o arquivo no seu computador.
dev.off()

# Gerar a visualização de controle de qualidade
print("Objeto chromR criado com sucesso! Gerando o gráfico...")
chromoqc(chrom, dp.alpha = 50)
```
```{r, cache=FALSE}
# ler arquivos vcf

vcf_Ca <- read.vcfR("Ca_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = TRUE)
vcf_Cc <- read.vcfR("Cc_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = TRUE)
vcf_Ce <- read.vcfR("Ce_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = TRUE)

#extrair contagem de reads do alelo alternativo
AOmat_Ca <- extract.gt(vcf_Ca, element = "AO", as.numeric = TRUE)
AOmat_Cc <- extract.gt(vcf_Cc, element = "AO", as.numeric = TRUE)
AOmat_Ce <- extract.gt(vcf_Ce, element = "AO", as.numeric = TRUE)

#extraindo profundidade

DPmat_Ca <- extract.gt(vcf_Ca, element = "DP", as.numeric = TRUE)
DPmat_Cc <- extract.gt(vcf_Cc, element = "DP", as.numeric = TRUE)
DPmat_Ce <- extract.gt(vcf_Ce, element = "DP", as.numeric = TRUE)

#Verificação
AOmat_Ca[1:10,1:5]

rm(vcf_Ca, vcf_Ce, vcf_Cc); gc(verbose = FALSE)
```
```{r, cache=FALSE}
counts_Ca <- table(matrix(unlist(strsplit(rownames(AOmat_Ca), split = "_")), ncol = 2, byrow = TRUE)[,1])
counts_Cc <- table(matrix(unlist(strsplit(rownames(AOmat_Cc), split = "_")), ncol = 2, byrow = TRUE)[,1])
counts_Ce <- table(matrix(unlist(strsplit(rownames(AOmat_Ce), split = "_")), ncol = 2, byrow = TRUE)[,1])

#converte em dataframe
counts_Ca <- data.frame(Reference=rep("Ca", length(counts_Ca)), counts_Ca)
counts_Ce <- data.frame(Reference=rep("Ce", length(counts_Ce)), counts_Ce)
counts_Ca <- data.frame(Reference=rep("Cc", length(counts_Cc)), counts_Cc)

# juntar os data frames

counts2x <- rbind(counts_Ca, counts_Ce, counts_Cc)

if (!require("stringr")) install.packages("stringr")
library(stringr)
counts2x$Chr <- as.integer(str_extract(counts2x$Var1, "\\d+")) # Extrai o número do cromossomo
counts2x$Subgenome <- ifelse(grepl("c", counts2x$Var1, ignore.case = TRUE) & grepl("Cc", counts2x$Reference), "canephora",
                           ifelse(grepl("e", counts2x$Var1, ignore.case = TRUE) & grepl("Ce", counts2x$Reference), "eugenioides", "arabica"))
library(ggplot2)

# Filtrar o dataframe, coluna 'Chr' NÃO é NA.
counts2x_filtered <- counts2x[!is.na(counts2x$Chr), ]


B <- ggplot(counts2x_filtered, aes(x = as.factor(Chr), y = Freq, fill = Reference)) +
  geom_bar(stat="identity", position = position_dodge(), alpha = 0.8) +
  scale_fill_manual(values = c("Cc" = "#993300", "Ce" = "#f5ad05"),
                    labels = c("Ref. Canephora", "Ref. Eugenioides")) +
  labs(x = "Cromossomo", y = "Número de SNPs", fill = "Alinhamento de Referência") +
  theme_classic() +
  theme(axis.text = element_text(size = 10),
        axis.title = element_text(size = 12, face = "bold"),
        legend.position = "top");

# Exibir o novo gráfico
print(B)

# Salvar o novo gráfico
ggsave("contagem_snps_por_cromossomo_v2.png", plot = B, width = 10, height = 6, dpi = 400)
```
