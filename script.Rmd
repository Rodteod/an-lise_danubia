---
title: "Untitled"
author: "Rodrigo"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r, cache=FALSE, message=FALSE, warning=FALSE, results='hide'}

if (!require("pacman")) install.packages("pacman")

pacotes_cran <- c(
  "devtools",
  "tidyverse",    # Coleção de pacotes para manipulação e visualização de dados (ggplot2, dplyr, etc.)
  "vcfR",         # Para ler e manipular arquivos VCF (seus dados genéticos)
  "CMplot",       # Para criar gráficos de Manhattan e outros gráficos genômicos
  "parallel",     # Para executar tarefas em paralelo e acelerar o processamento
  "ggpubr",       # Facilita a criação de gráficos prontos para publicação
  "ggh4x",        # Extensões para o ggplot2
  "grid",          # Funções gráficas de baixo nível
  "circlize",
  "onemap"
)
# formato "nome_do_usuario/nome_do_repositorio".
pacotes_github <- c(
  "dcgerard/segtest@higher", # Pacote para testes de segregação. A parte "@higher" instala uma versão específica.
  "dcgerard/updog",          # Para genotipagem de poliploides
  "dcgerard/ldsep",          # Para análise de desequilíbrio de ligação
  "jendelman/GWASpoly",      # Para estudos de associação genômica ampla (GWAS) em poliploides
  "mmollina/mappoly"         # Para construção de mapas de ligação em poliploides
)

pacman::p_load(char = pacotes_cran)
pacman::p_load_gh(char = pacotes_github)

rm(list = ls())
gc(verbose = FALSE)
```

```{r, cache=FALSE}

library(vcfR)
library(ape)
library(stringr)
library(ggplot2)

# Carregar os arquivos
vcf_Cc <- vcfR::read.vcfR("Cc_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf")
gff <- ape::read.gff("genomic.gff")
dna <- ape::read.dna("GCF_036785885.1_Coffea_Arabica_ET-39_HiFi_genomic.fna", format = "fasta")

# Criar a tabela de mapeamento
region_info <- gff[gff$type == "region", ]
bio_names <- sapply(as.character(region_info$attributes), function(attr_string) {
  fields <- strsplit(attr_string, ";")[[1]]
  chrom_field <- grep("chromosome=", fields, value = TRUE)
  if (length(chrom_field) == 0) return(NA)
  return(strsplit(chrom_field, "=")[[1]][2])
})
chrom_map <- data.frame(
  ncbi_id = as.character(region_info$seqid),
  bio_name = bio_names
)
chrom_map <- chrom_map[chrom_map$bio_name != "Unknown", ]
chrom_map <- na.omit(chrom_map)
```


```{r, cache=FALSE}
# Padronizar GFF: Substituir 'NC_...' por '1c', '1e', etc.
gff_chroms <- as.character(gff$seqid)
gff$seqid <- chrom_map$bio_name[match(gff_chroms, chrom_map$ncbi_id)]

# Padronizar DNA: Substituir 'NC_...' por '1c', '1e', etc.
dna_ids <- word(names(dna), 1) 
names(dna) <- chrom_map$bio_name[match(dna_ids, chrom_map$ncbi_id)]

# Padronizar VCF: Remover o prefixo 'chr' para ter '1c', '1e', etc.
vcf_Cc@fix[, 'CHROM'] <- gsub("chr", "", getCHROM(vcf_Cc))

# Remover qualquer elemento que não foi padronizado (virou NA)
gff <- gff[!is.na(gff$seqid), ]
dna <- dna[!is.na(names(dna))]
vcf_Cc <- vcf_Cc[!is.na(getCHROM(vcf_Cc)), ]

print("Nomes padronizados. Verificando o número de variantes restantes no VCF:")
print(nrow(vcf_Cc@fix))


# Selecionar a sequência de DNA para o cromossomo '1c'
dna_1c <- dna[names(dna) == '1c']

# Criar o objeto.
chrom <- create.chromR(name = '1c', vcf = vcf_Cc, seq = dna_1c, ann = gff)
png(filename = "grafico_qc_cromossomo_1c.png", width = 800, height = 1000)

# 2. Executa o comando para criar o gráfico.
chromoqc(chrom, dp.alpha = 50)

# 3. CRUCIAL: Fecha o dispositivo. Isso finaliza e salva o arquivo no seu computador.
dev.off()

# Gerar a visualização de controle de qualidade
print("Objeto chromR criado com sucesso! Gerando o gráfico...")
chromoqc(chrom, dp.alpha = 50)
```

```{r, cache=FALSE}
# ler arquivos vcf

vcf_Ca <- read.vcfR("Ca_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = TRUE)
vcf_Cc <- read.vcfR("Cc_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = TRUE)
vcf_Ce <- read.vcfR("Ce_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = TRUE)

#extrair contagem de reads do alelo alternativo
AOmat_Ca <- extract.gt(vcf_Ca, element = "AO", as.numeric = TRUE)
AOmat_Cc <- extract.gt(vcf_Cc, element = "AO", as.numeric = TRUE)
AOmat_Ce <- extract.gt(vcf_Ce, element = "AO", as.numeric = TRUE)

#extrair profundidade

DPmat_Ca <- extract.gt(vcf_Ca, element = "DP", as.numeric = TRUE)
DPmat_Cc <- extract.gt(vcf_Cc, element = "DP", as.numeric = TRUE)
DPmat_Ce <- extract.gt(vcf_Ce, element = "DP", as.numeric = TRUE)

#Verificação
AOmat_Ca[1:10,1:5]

rm(vcf_Ca, vcf_Ce, vcf_Cc); gc(verbose = FALSE)
```
```{r, cache=FALSE}
counts_Ca <- table(matrix(unlist(strsplit(rownames(AOmat_Ca), split = "_")), ncol = 2, byrow = TRUE)[,1])
counts_Cc <- table(matrix(unlist(strsplit(rownames(AOmat_Cc), split = "_")), ncol = 2, byrow = TRUE)[,1])
counts_Ce <- table(matrix(unlist(strsplit(rownames(AOmat_Ce), split = "_")), ncol = 2, byrow = TRUE)[,1])

#converte em dataframe
counts_Ca <- data.frame(Reference=rep("Ca", length(counts_Ca)), counts_Ca)
counts_Ce <- data.frame(Reference=rep("Ce", length(counts_Ce)), counts_Ce)
counts_Cc <- data.frame(Reference=rep("Cc", length(counts_Cc)), counts_Cc)

# juntar os data frames

counts2x <- rbind(counts_Ca, counts_Ce, counts_Cc)

if (!require("stringr")) install.packages("stringr")
library(stringr)
counts2x$Chr <- as.integer(str_extract(counts2x$Var1, "\\d+")) # Extrai o número do cromossomo
counts2x$Subgenome <- ifelse(grepl("c", counts2x$Var1, ignore.case = TRUE) & grepl("Cc", counts2x$Reference), "canephora",
                           ifelse(grepl("e", counts2x$Var1, ignore.case = TRUE) & grepl("Ce", counts2x$Reference), "eugenioides", "arabica"))
library(ggplot2)

# Filtrar o dataframe, coluna 'Chr' NÃO é NA.
counts2x_filtered <- counts2x[!is.na(counts2x$Chr), ]


B <- ggplot(counts2x_filtered, aes(x = as.factor(Chr), y = Freq, fill = Reference)) +
  geom_bar(stat="identity", position = position_dodge(), alpha = 0.8) +
  scale_fill_manual(values = c("Cc" = "#993300", "Ce" = "#f5ad05"),
                    labels = c("Canephora", "Eugenioides")) +
  labs(x = "Chromosome", y = "Number of SNPs", fill = "Reference") +
  theme_classic() +
  theme(axis.text = element_text(size = 10),
        axis.title = element_text(size = 12, face = "bold"),
        legend.position = "top");

# Exibir o novo gráfico
print(B)

# Salvar o novo gráfico
ggsave("contagem_snps_por_cromossomo_v2.png", plot = B, width = 10, height = 6, dpi = 400)
```

```{r, cache=FALSE}
vcf_Cc <- read.vcfR("Cc_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = TRUE)
vcf_Ce <- read.vcfR("Ce_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = TRUE)
vcf_Ca <- read.vcfR("Ca_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = TRUE)

GTmat_Cc4 <- extract.gt(vcf_Cc, element = "GT", as.numeric = FALSE); GTmat_Cc4[1:10,1:5]; dim(GTmat_Cc4); table(GTmat_Cc4)

AOmat_Ca <- extract.gt(vcf_Ca, element = "AO", as.numeric = TRUE)
AOmat_Cc <- extract.gt(vcf_Cc, element = "AO", as.numeric = TRUE)
AOmat_Ce <- extract.gt(vcf_Ce, element = "AO", as.numeric = TRUE)
DPmat_Ca <- extract.gt(vcf_Ca, element = "DP", as.numeric = TRUE)
DPmat_Cc <- extract.gt(vcf_Cc, element = "DP", as.numeric = TRUE)
DPmat_Ce <- extract.gt(vcf_Ce, element = "DP", as.numeric = TRUE)

rm(vcf_Ca, vcf_Cc, vcf_Ce); gc(verbose = FALSE)

```

```{r, cache=FALSE}
dim(DPmat_Ca)
dim(DPmat_Cc)
dim(DPmat_Ce)
hist(DPmat_Ca, breaks = 300)
hist(DPmat_Ce, breaks = 300)
hist(DPmat_Cc, breaks = 300)

widemat_Ca <- data.frame(SNP=rownames(DPmat_Ca), Reference = "Ca", DPmat_Ca)
widemat_Ce <- data.frame(SNP=rownames(DPmat_Ce), Reference = "Ce", DPmat_Ce)
widemat_Cc <- data.frame(SNP=rownames(DPmat_Cc), Reference = "Cc", DPmat_Cc)

longmat_Ca <- tidyr::pivot_longer(as.data.frame(widemat_Ca), cols = -c(1:2), names_to = "Amostra", values_to = "DP")
longmat_Ce <- tidyr::pivot_longer(as.data.frame(widemat_Ce), cols = -c(1:2), names_to = "Amostra", values_to = "DP")
longmat_Cc <- tidyr::pivot_longer(as.data.frame(widemat_Cc), cols = -c(1:2), names_to = "Amostra", values_to = "DP")

longmat <- rbind(longmat_Cc, longmat_Ce, longmat_Ca)
```

```{r, cache=FALSE}
A <- ggplot(longmat) +
  geom_histogram(aes(x = DP, fill = Reference), position = "identity", bins = 200, alpha = 0.7) +
  facet_grid(Reference ~ ., scales = "free_y") + # Painéis separados para cada referência
  scale_fill_manual(values = c("Ca" = "grey", "Cc" = "#993300", "Ce" = "#f5ad05")) +
 # scale_x_continuous(limits = c(0, 200), expand = c(0,0)) + # Focando em profundidades de 0 a 200
  labs(x = "Profundidade de Leitura (DP)", y = "Frequência") +
  theme_classic()


B <- ggplot(longmat) +
  geom_boxplot(aes(y = Reference, x = DP, fill = Reference)) +
  scale_fill_manual(values = c("Ca" = "grey", "Cc" = "#993300", "Ce" = "#f5ad05")) +
  #scale_x_continuous(limits = c(0, 200), expand = c(0,0)) +
  labs(x = "Profundidade de Leitura (DP)", y = "") +
  theme_classic() +
  theme(legend.position = "none")

# combinar os dois gráficos em uma única figura
cowplot::plot_grid(B, A, ncol = 1, rel_heights = c(0.7, 2), align = 'v', axis = 'lr')
ggsave("distribuicao_profundidade_leitura.png", width = 8, height = 6, dpi = 300)


tapply(longmat$DP, longmat$Reference, median, na.rm = TRUE)
```
```{r, cache=FALSE}

# contagem de reads do alelo referencia 
ROmat_Cc <- DPmat_Cc - AOmat_Cc
ROmat_Ce <- DPmat_Ce - AOmat_Ce
ROmat_Ca <- DPmat_Ca - AOmat_Ca


#calculo de cobertura para cada genótipo
ROmat2_Cc <- ROmat_Cc^2
ROmat2_Ce <- ROmat_Ce^2
ROmat2_Ca <- ROmat_Ca^2
AOmat2_Cc <- AOmat_Cc^2
AOmat2_Ce <- AOmat_Ce^2
AOmat2_Ca <- AOmat_Ca^2

SQmat_Cc <- sqrt(AOmat2_Cc + ROmat2_Cc)
SQmat_Ce <- sqrt(AOmat2_Ce + ROmat2_Ce)
SQmat_Ca <- sqrt(AOmat2_Ca + ROmat2_Ca)

# -- Para o alinhamento Canephora (Cc) --
cat("\nIniciando filtro adaptativo para Cc...\n")
# Checando o número de NAs ANTES do filtro.
cat("NAs em DPmat_Cc ANTES:", sum(is.na(DPmat_Cc)), "\n")

for (m in 1:nrow(DPmat_Cc)) {
  median_coverage <- median(SQmat_Cc[m,], na.rm = TRUE)
  exclude <- which(SQmat_Cc[m,] < (0.10* median_coverage)) 
  DPmat_Cc[m, exclude] <- NA
  AOmat_Cc[m, exclude] <- NA
}

cat("NAs em DPmat_Cc DEPOIS:", sum(is.na(DPmat_Cc)), "\n")

for (m in 1:nrow(DPmat_Ce)) {
  media_coverage <- median(SQmat_Ce[m,], na.rm = TRUE)
  exclude <- which(SQmat_Ce[m,] < (0.10*media_coverage))
  DPmat_Ce[m, exclude] <- NA
  AOmat_Ce[m, exclude] <- NA
}

for (m in 1:nrow(DPmat_Ca)) {
  media_coverage <- median(SQmat_Ca[m,], na.rm = TRUE)
  exclude <- which(SQmat_Ca[m,] < (0.10*media_coverage))
  DPmat_Ca[m, exclude] <- NA
  AOmat_Ca[m, exclude] <- NA
}

rm(ROmat_Cc, ROmat2_Cc, AOmat2_Cc, SQmat_Cc); gc(verbose = FALSE)
rm(ROmat_Ce, ROmat2_Ce, AOmat2_Ce, SQmat_Ce); gc(verbose = FALSE)
rm(ROmat_Ca, ROmat2_Ca, AOmat2_Ca, SQmat_Ca); gc(verbose = FALSE)

```

```{r, cache=FALSE}


count.na <- function(x) { sum(is.na(x)) }


cat("\nFiltrando indivíduos com mais de 25% de dados faltantes...\n")
# 'apply(DPmat_Cc, 2, ...)' aplica a função a cada coluna (2 = colunas).
# Conta NAs por indivíduo.
ind.nas_Cc <- apply(DPmat_Cc, 2, count.na)
ind.nas_Ce <- apply(DPmat_Ce, 2, count.na)
ind.nas_Ca <- apply(DPmat_Ca, 2, count.na)

# Remover individuos > 25% de NAs.
threshold_ind_Cc <- nrow(DPmat_Cc) * 0.25
threshold_ind_Ce <- nrow(DPmat_Ce) * 0.25
threshold_ind_Ca <- nrow(DPmat_Ca) * 0.25
ind_to_remove_Cc <- which(ind.nas_Cc > threshold_ind_Cc)
ind_to_remove_Ce <- which(ind.nas_Ce > threshold_ind_Ce)
ind_to_remove_Ca <- which(ind.nas_Ca > threshold_ind_Ca)

cat("Indivíduos a remover de Cc:", length(ind_to_remove_Cc), "\n")
cat("Indivíduos a remover de Ce:", length(ind_to_remove_Ce), "\n")
cat("Indivíduos a remover de Ca:", length(ind_to_remove_Ca), "\n")

if(length(ind_to_remove_Cc) > 0) {
  AOmat_Cc <- AOmat_Cc[, -ind_to_remove_Cc]
  DPmat_Cc <- DPmat_Cc[, -ind_to_remove_Cc]
}
if(length(ind_to_remove_Ce) > 0) {
  AOmat_Ce <- AOmat_Ce[, -ind_to_remove_Ce]
  DPmat_Ce <- DPmat_Ce[, -ind_to_remove_Ce]
}

if(length(ind_to_remove_Ce) > 0) {
  AOmat_Ca <- AOmat_Ca[, -ind_to_remove_Ca]
  DPmat_Ca <- DPmat_Ca[, -ind_to_remove_Ca]
}

cat("\nFiltrando marcadores com mais de 25% de dados faltantes...\n")
# Conta NAs por marcador.
mrk.nas_Cc <- apply(DPmat_Cc, 1, count.na)
mrk.nas_Ce <- apply(DPmat_Ce, 1, count.na)
mrk.nas_Ca <- apply(DPmat_Ca, 1, count.na)

# Define os marcadores a serem removidos.
threshold_mrk_Cc <- ncol(DPmat_Cc) * 0.25
threshold_mrk_Ce <- ncol(DPmat_Ce) * 0.25
threshold_mrk_Ca <- ncol(DPmat_Ca) * 0.25

mrk_to_remove_Cc <- which(mrk.nas_Cc > threshold_mrk_Cc)
mrk_to_remove_Ce <- which(mrk.nas_Ce > threshold_mrk_Ce)
mrk_to_remove_Ca <- which(mrk.nas_Ca > threshold_mrk_Ca)

cat("Marcadores a remover de Cc:", length(mrk_to_remove_Cc), "\n")
cat("Marcadores a remover de Ce:", length(mrk_to_remove_Ce), "\n")
cat("Marcadores a remover de Ca:", length(mrk_to_remove_Ca), "\n")

# Remove as linhas (marcadores) identificadas.
if(length(mrk_to_remove_Cc) > 0) {
  AOmat_Cc <- AOmat_Cc[-mrk_to_remove_Cc, ]
  DPmat_Cc <- DPmat_Cc[-mrk_to_remove_Cc, ]
}
if(length(mrk_to_remove_Ce) > 0) {
  AOmat_Ce <- AOmat_Ce[-mrk_to_remove_Ce, ]
  DPmat_Ce <- DPmat_Ce[-mrk_to_remove_Ce, ]
}

if(length(mrk_to_remove_Ca) > 0) {
  AOmat_Ca <- AOmat_Ca[-mrk_to_remove_Ca, ]
  DPmat_Ca <- DPmat_Ca[-mrk_to_remove_Ca, ]
}

cat("\nDimensões finais das matrizes:\n")
cat("AOmat_Cc:", dim(AOmat_Cc), "\n")
cat("DPmat_Cc:", dim(DPmat_Cc), "\n")
cat("AOmat_Ce:", dim(AOmat_Ce), "\n")
cat("DPmat_Ce:", dim(DPmat_Ce), "\n")
cat("AOmat_Ca:", dim(AOmat_Ca), "\n")
cat("DPmat_Ca:", dim(DPmat_Ca), "\n")

# Salva as matrizes limpas em arquivos para uso futuro.
save(AOmat_Cc, DPmat_Cc, file = "matrizes_filtradas_Cc.rda")
save(AOmat_Ce, DPmat_Ce, file = "matrizes_filtradas_Ce.rda")
save(AOmat_Ca, DPmat_Ca, file = "matrizes_filtradas_Ca.rda")



```

```{r,cache=FALSE}

library(updog)

nc <- parallel::detectCores() - 1
cat("Usando", nc, "núcleos para o processamento.\n")



cat("\nCarregando dados filtrados de Cc e iniciando updog...\n")
load("matrizes_filtradas_Cc.rda")
cat("Dimensões dos dados de entrada (SNPs x Amostras):", dim(AOmat_Cc), "\n")


mout_Cc <- multidog(refmat = AOmat_Cc, 
                    sizemat = DPmat_Cc, 
                    ploidy = 4, 
                    model = "s1pp", 
                    nc = nc)

cat("Análise de Cc concluída. Salvando resultados...\n")
save(mout_Cc, file="mout_Cc.rda")
rm(mout_Cc, AOmat_Cc, DPmat_Cc); gc(verbose = FALSE)
cat("Resultados de Cc salvos em 'mout_Cc.rda'.\n")


# alinhamento Eugenioides (Ce) 
cat("\nCarregando dados filtrados de Ce e iniciando updog...\n")
load("matrizes_filtradas_Ce.rda")
cat("Dimensões dos dados de entrada (SNPs x Amostras):", dim(AOmat_Ce), "\n")


mout_Ce <- multidog(refmat = AOmat_Ce, 
                    sizemat = DPmat_Ce, 
                    ploidy = 4, 
                    model = "s1pp", 
                    nc = nc)

cat("Análise de Ce concluída. Salvando resultados...\n")
save(mout_Ce, file="mout_Ce.rda")
rm(mout_Ce, AOmat_Ce, DPmat_Ce); gc(verbose = FALSE)
cat("Resultados de Ce salvos em 'mout_Ce.rda'.\n")
```


```{r, cache=FALSE}
library(updog)

nc <- parallel::detectCores() - 1
cat("Usando", nc, "núcleos para o processamento.\n")



cat("\nCarregando dados filtrados de Cc e iniciando updog...\n")
load("matrizes_filtradas_Ca.rda")
cat("Dimensões dos dados de entrada (SNPs x Amostras):", dim(AOmat_Ca), "\n")

# Executa o modelo multidog.
mout_Ca <- multidog(refmat = AOmat_Ca, 
                    sizemat = DPmat_Ca, 
                    ploidy = 4, 
                    model = "s1pp", 
                    nc = nc)
cat("Análise de Ca concluída. Salvando resultados...\n")
save(mout_Ca, file="mout_Ca.rda")
rm(mout_Ca, AOmat_Ca, DPmat_Ca); gc(verbose = FALSE)
cat("Resultados de Ce salvos em 'mout_Ce.rda'.\n")
```

```{r, eval=FALSE}
library(updog)

load("mout_Cc.rda")
nmrk <- length(mout_Cc$snpdf$snp)
indices <- split(1:nmrk, ceiling(1:nmrk/100))
dir.create(path = "plots_Cc", showWarnings = FALSE)
for(i in 1:length(indices)) {
  pdf(paste0("plots_Cc/mout_Cc_",i,".pdf"), width = 6, height = 5)
  print(plot(mout_Cc, indices=indices[[i]]))
  dev.off()
}

load("mout_Ce.rda")
nmrk <- length(mout_Ce$snpdf$snp)
indices <- split(1:nmrk, ceiling(1:nmrk/100))
dir.create(path = "plots_Ce", showWarnings = FALSE)
for(i in 1:length(indices)) {
  pdf(paste0("plots_Ce/mout_Ce_",i,".pdf"), width = 6, height = 5)
  print(plot(mout_Ce, indices=indices[[i]]))
  dev.off()
}

load("mout_Ca.rda")
nmrk <- length(mout_Ca$snpdf$snp)
indices <- split(1:nmrk, ceiling(1:nmrk/100))#Lista: cada elemento em um vetor com 100 SNPs
dir.create(path = "plots_Ca", showWarnings = FALSE) #cria uma pasta
for(i in 1:length(indices)) {
  pdf(paste0("plots_Ca/mout_Ca_",i,".pdf"), width = 6, height = 5)
  print(plot(mout_Ca, indices=indices[[i]]))
  dev.off()
}
```



```{r}
# library(vcfR)
# library(dplyr)   # ou library(tidyverse)
# library(ggplot2)

drawsp <- function(vcf, 
                            snp, 
                            ploidy = 4, 
                            samples_to_remove = NULL, 
                            title = NULL, 
                            color_palette = c("0" = "#0072B2", "1" = "#009E73", "2" = "#D55E00", 
                                              "3" = "#CC79A7", "4" = "#F0E442", "NA" = "grey50")) {
  
  vcf_long <- vcfR2tidy(vcf, single_frame = TRUE)
  
  vcf_long$dat$gt_AO <- as.integer(vcf_long$dat$gt_AO)
  vcf_long$dat$gt_RO <- as.integer(vcf_long$dat$gt_RO) # Adicionado para garantir que RO também é numérico
  vcf_long$dat$gt_GT_alleles[vcf_long$dat$gt_GT_alleles == "."] <- NA
  vcf_long$dat$ID <- paste(vcf_long$dat$CHROM, vcf_long$dat$POS, sep = "_")
  
  dfdat <- vcf_long$dat %>% filter(ID == snp)
  
  if (nrow(dfdat) == 0) {
    stop(paste0("ERRO: O SNP '", snp, "' não foi encontrado no arquivo VCF."))
  }
  
  if (!is.null(samples_to_remove)) {
    # A coluna com nomes de amostra no vcfR2tidy é 'Indiv'
    dfdat <- dfdat %>% filter(!Indiv %in% samples_to_remove)
    
    if (nrow(dfdat) == 0) {
      stop(paste0("ERRO: Todas as amostras para o SNP '", snp, "' foram removidas."))
    }
  }
  
  dfdat$Dose <- factor(
    unlist(lapply(lapply(strsplit(dfdat$gt_GT, "/"), as.integer), sum)), 
    levels = 0:ploidy, # Garante que todos os níveis de dose existam
    ordered = TRUE
  )
  
  # 6. Calcula as linhas de referência para as proporções alélicas esperadas
  pk <- (0:ploidy)/ploidy
  maxcount <- max(c(dfdat$gt_RO, dfdat$gt_AO), na.rm = TRUE) + 1
  slopevec <- pk/(1 - pk)
  xend <- pmin(rep(maxcount, ploidy + 1), maxcount/slopevec)
  yend <- pmin(rep(maxcount, ploidy + 1), maxcount * slopevec)
  df_lines <- data.frame(x = 0, y = 0, xend = xend, yend = yend, Dose = factor(0:ploidy))

  # 7. Constrói o gráfico com ggplot2
  plot_title <- if (is.null(title)) snp else title
  
  p <- ggplot(dfdat, aes(x = gt_RO, y = gt_AO)) +
    geom_point(aes(color = Dose), na.rm = TRUE, size = 2, alpha = 0.8) +
    geom_segment(data = df_lines, mapping = aes(x = x, y = y, xend = xend, yend = yend), 
                 lty = 2, alpha = 0.7, color = "black", linewidth = 0.5) +
    scale_color_manual(values = color_palette, 
                       name = "Dose",
                       drop = FALSE, # Garante que todas as cores da legenda apareçam
                       na.translate = FALSE) +
    labs(title = plot_title, 
         x = "Contagem Alelo Referência (RO)", 
         y = "Contagem Alelo Alternativo (AO)") +
    theme_bw(base_size = 12) + 
    theme(
      plot.title = element_text(hjust = 0.5),
      legend.position = "right"
    )
  
  return(p)
}
```

```{r}
load("mout_Cc.rda")

library(vcfR)

vcf_Cc_raw <- read.vcfR("Cc_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = FALSE)

snp_metrics_Cc <- mout_Cc$snpdf

summary(snp_metrics_Cc[, c( "bias", "od", "prop_mis")])

best_snps <- snp_metrics_Cc %>% 
  dplyr::filter(prop_mis < 0.02, bias > 0.9, bias < 1.1, od < 0.01) %>% # filtra os SNPs
  dplyr::slice_sample(n=5) %>% # pega 5 exemplos aleatórios 
  dplyr::pull(snp) #extrai apenas o nome dos SNPs

print(best_snps)

worst_snps <- snp_metrics_Cc %>%
  dplyr::filter(prop_mis > 0.4) %>%
  dplyr::slice_sample(n = 5) %>%
  dplyr::pull(snp)

print(worst_snps)


biased_snps <- snp_metrics_Cc %>%
  dplyr::filter(prop_mis < 0.1, bias > 1.5 | bias < 0.7) %>%
  dplyr::slice_sample(n = 5) %>%
  dplyr::pull(snp)

print(biased_snps)
```
``

```{r,cache=FALSE}
col_pal = c(`0`="#E69F00", `1`="#56B4E9", `2`="#009E73", `3`="#CC46A7", `4`="#999999", `NA` = "grey50")
#dir.create("diagnostico_snps", showWarnings = FALSE)
#dir.create("diagnostico_snps/melhores_snps_Cc", showWarnings = FALSE)
#dir.create("diagnostico_snps/snps_com_vies_Cc", showWarnings = FALSE)

for (snp_id in best_snps) {
  
  # Gráfico 1: Genotipagem bruta do VCF (usando sua função)
  p1 <- drawsp(vcf = vcf_Cc_raw, snp = snp_id, ploidy = 4, title = TRUE) + labs(x = "Reads Ref.", y = "Reads Alt.")
  
  # Gráfico 2: Genotipagem do updog
 p2 <- updog:::plot.multidog(mout_Cc, indices = which(mout_Cc$snpdf$snp == snp_id))[[1]] +
      scale_color_manual(values = col_pal, drop = FALSE, na.translate = FALSE) +
      labs(color = "Dose (updog)", alpha = "Prob. Post.") +
      theme(legend.position="top", plot.title = element_blank())
    
  # Combina os dois gráficos
  combined_plot <- ggpubr::ggarrange(p1, p2, ncol = 2, labels = c("FreeBayes", "Updog"), common.legend = FALSE, legend = "bottom")
  
  # Salva o gráfico combinado em um arquivo
  ggsave(filename = paste0("diagnostico_snps/melhores_snps_Cc/", snp_id, ".png"),
    plot = combined_plot,
    width = 10, height = 5, dpi = 150
  )
  }

for (snp_id in worst_snps) {
  
  # Gráfico 1: Genotipagem bruta do VCF (usando sua função)
  p1 <- drawsp(vcf = vcf_Cc_raw, snp = snp_id, ploidy = 4, title = TRUE) + labs(x = "Reads Ref.", y = "Reads Alt.")
  
  # Gráfico 2: Genotipagem do updog
 p2 <- updog:::plot.multidog(mout_Cc, indices = which(mout_Cc$snpdf$snp == snp_id))[[1]] +
      scale_color_manual(values = col_pal, drop = FALSE, na.translate = FALSE) +
      labs(color = "Dose (updog)", alpha = "Prob. Post.") +
      theme(legend.position="top", plot.title = element_blank())
    
  # Combina os dois gráficos
  combined_plot <- ggpubr::ggarrange(p1, p2, ncol = 2, labels = c("FreeBayes", "Updog"), common.legend = FALSE, legend = "bottom")
  
  # Salva o gráfico combinado em um arquivo
  ggsave(filename = paste0("diagnostico_snps/piores_snps_Cc/", snp_id, ".png"),
    plot = combined_plot,
    width = 10, height = 5, dpi = 150
  )
}

for (snp_id in biased_snps) {
  
  # Gráfico 1: Genotipagem bruta do VCF (usando sua função)
  p1 <- drawsp(vcf = vcf_Cc_raw, snp = snp_id, ploidy = 4, title = TRUE) + labs(x = "Reads Ref.", y = "Reads Alt.")
  
  # Gráfico 2: Genotipagem do updog
 p2 <- updog:::plot.multidog(mout_Cc, indices = which(mout_Cc$snpdf$snp == snp_id))[[1]] +
      scale_color_manual(values = col_pal, drop = FALSE, na.translate = FALSE) +
      labs(color = "Dose (updog)", alpha = "Prob. Post.") +
      theme(legend.position="top", plot.title = element_blank())
    
  # Combina os dois gráficos
  combined_plot <- ggpubr::ggarrange(p1, p2, ncol = 2, labels = c("FreeBayes", "Updog"), common.legend = FALSE, legend = "bottom")
  
  # Salva o gráfico combinado em um arquivo
  ggsave(filename = paste0("diagnostico_snps/snps_com_vies_Cc/", snp_id, ".png"),
    plot = combined_plot,
    width = 10, height = 5, dpi = 150
  )
}
```

```{r}
load("mout_Ce.rda")

library(vcfR)

vcf_Ce_raw <- read.vcfR("Ce_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = FALSE)

snp_metrics_Ce <- mout_Ce$snpdf

summary(snp_metrics_Ce[, c( "bias", "od", "prop_mis")])

best_snps_Ce <- snp_metrics_Ce %>% 
  dplyr::filter(prop_mis < 0.02, bias > 0.9, bias < 1.1, od < 0.01) %>% # filtra os SNPs
  dplyr::slice_sample(n=5) %>% # pega 5 exemplos aleatórios 
  dplyr::pull(snp) #extrai apenas o nome dos SNPs

print(best_snps_Ce)

worst_snps_Ce <- snp_metrics_Ce %>%
  dplyr::filter(prop_mis > 0.4) %>%
  dplyr::slice_sample(n = 5) %>%
  dplyr::pull(snp)

print(worst_snps_Ce)


biased_snps_Ce <- snp_metrics_Ce %>%
  dplyr::filter(prop_mis < 0.1, bias > 1.5 | bias < 0.7) %>%
  dplyr::slice_sample(n = 5) %>%
  dplyr::pull(snp)

print(biased_snps_Ce)
```

```{r}
col_pal = c(`0`="#E69F00", `1`="#56B4E9", `2`="#009E73", `3`="#CC46A7", `4`="#999999", `NA` = "grey50")
#dir.create("diagnostico_snps", showWarnings = FALSE)
dir.create("diagnostico_snps/melhores_snps_Ce", showWarnings = FALSE)
dir.create("diagnostico_snps/piores_snps_Ce", showWarnings = FALSE)
dir.create("diagnostico_snps/snps_com_vies_Ce", showWarnings = FALSE)

for (snp_id in best_snps_Ce) {
  
  # Gráfico 1: Genotipagem bruta do VCF (usando sua função)
  p1 <- drawsp(vcf = vcf_Ce_raw, snp = snp_id, ploidy = 4, title = TRUE) + labs(x = "Reads Ref.", y = "Reads Alt.")
  
  # Gráfico 2: Genotipagem do updog
 p2 <- updog:::plot.multidog(mout_Ce, indices = which(mout_Ce$snpdf$snp == snp_id))[[1]] +
      scale_color_manual(values = col_pal, drop = FALSE, na.translate = FALSE) +
      labs(color = "Dose (updog)", alpha = "Prob. Post.") +
      theme(legend.position="top", plot.title = element_blank())
    
  # Combina os dois gráficos
  combined_plot <- ggpubr::ggarrange(p1, p2, ncol = 2, labels = c("FreeBayes", "Updog"), common.legend = FALSE, legend = "bottom")
  
  # Salva o gráfico combinado em um arquivo
  ggsave(filename = paste0("diagnostico_snps/melhores_snps_Ce/", snp_id, ".png"),
    plot = combined_plot,
    width = 10, height = 5, dpi = 150
  )
  }

for (snp_id in worst_snps_Ce) {
  
  # Gráfico 1: Genotipagem bruta do VCF (usando sua função)
  p1 <- drawsp(vcf = vcf_Ce_raw, snp = snp_id, ploidy = 4, title = TRUE) + labs(x = "Reads Ref.", y = "Reads Alt.")
  
  # Gráfico 2: Genotipagem do updog
 p2 <- updog:::plot.multidog(mout_Ce, indices = which(mout_Ce$snpdf$snp == snp_id))[[1]] +
      scale_color_manual(values = col_pal, drop = FALSE, na.translate = FALSE) +
      labs(color = "Dose (updog)", alpha = "Prob. Post.") +
      theme(legend.position="top", plot.title = element_blank())
    
  # Combina os dois gráficos
  combined_plot <- ggpubr::ggarrange(p1, p2, ncol = 2, labels = c("FreeBayes", "Updog"), common.legend = FALSE, legend = "bottom")
  
  # Salva o gráfico combinado em um arquivo
  ggsave(filename = paste0("diagnostico_snps/piores_snps_Ce/", snp_id, ".png"),
    plot = combined_plot,
    width = 10, height = 5, dpi = 150
  )
}

for (snp_id in biased_snps_Ce) {
  
  # Gráfico 1: Genotipagem bruta do VCF (usando sua função)
  p1 <- drawsp(vcf = vcf_Ce_raw, snp = snp_id, ploidy = 4, title = TRUE) + labs(x = "Reads Ref.", y = "Reads Alt.")
  
  # Gráfico 2: Genotipagem do updog
 p2 <- updog:::plot.multidog(mout_Ce, indices = which(mout_Ce$snpdf$snp == snp_id))[[1]] +
      scale_color_manual(values = col_pal, drop = FALSE, na.translate = FALSE) +
      labs(color = "Dose (updog)", alpha = "Prob. Post.") +
      theme(legend.position="top", plot.title = element_blank())
    
  # Combina os dois gráficos
  combined_plot <- ggpubr::ggarrange(p1, p2, ncol = 2, labels = c("FreeBayes", "Updog"), common.legend = FALSE, legend = "bottom")
  
  # Salva o gráfico combinado em um arquivo
  ggsave(filename = paste0("diagnostico_snps/snps_com_vies_Ce/", snp_id, ".png"),
    plot = combined_plot,
    width = 10, height = 5, dpi = 150
  )
}
```

```{r}

# aaaa maybe due to sequencing error, also accounted for using updog
aaaa_erro <- c("chr1c_1937030", "chr1c_2728355", "chr1c_32737985", "chr1c_39646867", "chr1c_41816140", "chr1c_43315765")
# aaaa with outlier
aaaa_outlier <-c ("chr1c_35257907", "chr1c_42787710", "chr2c_19211303", "chr6c_16480280", "chr6c_49097512", "chr9c_27895758", "chr10c_45003537")
# AAAA
AAAA <- c("chr1c_35471537", "chr2c_12074295", "chr10c_8893803")
# AAAA with outlier
AAAA_outlier <- c("chr1c_36854704", "chr1c_36854711", "chr1c_36898126", "chr1c_36898234", "chr6c_6375311")
# Aaaa with outlier
Aaaa_outlier <- c("chr1c_11885138", "chr1c_13025242", "chr1c_36424922", "chr1c_36915786", "chr1c_39215113", "chr1c_43563586", "chr6c_19239262", "chr7c_644004")
# AAAa with outlier
AAAa_outlier <- c("chr1c_39215106", "chr1c_42378219", "chr1c_43339885", "chr1c_43551084", "chr1c_44035918", "chr1c_46361101", "chr1c_46387209", "chr1c_46699985", "chr6c_379503", "chr6c_416459", "chr6c_505874", "chr6c_1055987", "chr7c_33856", "chr7c_217030", "chr7c_556509")
# AAAa with strong bias
AAAa_strong_bias <- "chr6c_22668973"
# 5 class strong bias
strong_bias5 <- c("chr1c_2617824", "chr1c_2617906", "chr1c_38266666", "chr1c_40338791", "chr1c_42787787", "chr1c_44938787")
# AAaa with outlier
AAaa_outlier <- c("chr2c_739600", "chr2c_2072206", "chr2c_6819987", "chr2c_66349790", "chr2c_67448604", "chr3c_911824", "chr4c_241263", "chr4c_732019", "chr4c_2295247", "chr4c_41014314", "chr5c_1969721", "chr5c_3778780", "chr5c_10744191", "chr5c_36975052", "chr5c_40676357", "chr5c_41575586", "chr6c_726367", "chr7c_217042", "chr7c_556416", "chr7c_1561232", "chr7c_1561274", "chr7c_3261969", "chr7c_5040433", "chr7c_5300901", "chr7c_7298062", "chr7c_7883290", "chr7c_8466466", "chr7c_12244742", "chr8c_32159518", "chr10c_116237", "chr10c_2693933", "chr10c_4169939", "chr10c_6067265", "chr10c_43264304", "chr11c_35360952")
# Aa00 with outlier
Aa00_outlier <- c("chr5c_1069263", "chr6c_565948", "chr6c_1483304", "chr6c_2176991", "chr6c_22282588", "chr6c_42831823", "chr6c_45309003", "chr6c_52098379", "chr7c_16463248", "chr7c_25491309", "chr9c_317654", "chr9c_1704466", "chr9c_3868628", "chr9c_25884837", "chr9c_27763272", "chr10c_10130285", "chr11c_1744478", "chr11c_2301165", "chr11c_3116828", "chr11c_25093312", "chr11c_28797521")
```

```{r}

for (snp_id in strong_bias5) {
  
  # Gráfico 1: Genotipagem bruta do VCF (usando sua função)
  p1 <- drawsp(vcf = vcf_Cc_raw, snp = snp_id, ploidy = 4, title = TRUE) + labs(x = "Reads Ref.", y = "Reads Alt.")
  
  # Gráfico 2: Genotipagem do updog
 p2 <- updog:::plot.multidog(mout_Cc, indices = which(mout_Cc$snpdf$snp == snp_id))[[1]] +
      scale_color_manual(values = col_pal, drop = FALSE, na.translate = FALSE) +
      labs(color = "Dose (updog)", alpha = "Prob. Post.") +
      theme(legend.position="top", plot.title = element_blank())
    
  # Combina os dois gráficos
  combined_plot <- ggpubr::ggarrange(p1, p2, ncol = 2, labels = c("FreeBayes", "Updog"), common.legend = FALSE, legend = "bottom")
  
  # Salva o gráfico combinado em um arquivo
  ggsave(filename = paste0("diagnostico_snps/strong_bias5/", snp_id, ".png"),
    plot = combined_plot,
    width = 10, height = 5, dpi = 150
  )
}
```

```{r, cache=FALSE}

load("mout_Cc.rda")

table(mout_Cc$snpdf$ell1) # ell1: The estimated dosage of the parent.
table(mout_Cc$snpdf$tau1 > 0) # tau1: The estimated double reduction parameter of the parent. Available if ell1 is 1, 2, or 3. Identified if ell1 is 1 or 3.
hist(mout_Cc$snpdf$tau1, breaks = 300)
table(mout_Cc$snpdf$gamma1 > 0) # gamma1: The estimated preferential pairing parameter. Available if ell1 is 2. However, it is not returned in an identified form.
hist(mout_Cc$snpdf$gamma1, breaks = 300)

```

Extract dosage calls:

```{r, eval=FALSE}
load("mout_Ca.rda")
snp_Ca <- format_multidog(mout_Ca, varname = "geno"); dim(snp_Ca)
save(snp_Ca, file = "snp_Ca.rda")
rm(mout_Ca); gc(verbose = FALSE)
load("mout_Cc.rda")
snp_Cc <- format_multidog(mout_Cc, varname = "geno"); dim(snp_Cc)
save(snp_Cc, file = "snp_Cc.rda")
rm(mout_Cc); gc(verbose = FALSE)
load("mout_Ce.rda")
snp_Ce <- format_multidog(mout_Ce, varname = "geno"); dim(snp_Ce)
save(snp_Ce, file = "snp_Ce.rda")
rm(mout_Ce); gc(verbose = FALSE)
```


```{r}
load("mout_Cc.rda")
load("mout_Ce.rda")
load("snp_Cc.rda"); dim(snp_Cc)
load("snp_Ce.rda"); dim(snp_Ce)
class_Cc <- apply(snp_Cc, 1, table)
class_Ce <- apply(snp_Ce, 1, table)

number_class_Cc <- unlist(lapply(class_Cc, length))
number_class_Ce <- unlist(lapply(class_Ce, length))

names(number_class_Cc) <- as.integer(extract_numeric(matrix(unlist(strsplit(names(number_class_Cc), split = "_")), ncol = 2, byrow = TRUE)[,1]))
names(number_class_Ce) <- as.integer(extract_numeric(matrix(unlist(strsplit(names(number_class_Ce), split = "_")), ncol = 2, byrow = TRUE)[,1]))

round(table(number_class_Cc, mout_Cc$snpdf$ell1)/sum(table(number_class_Cc))*100)
round(table(names(number_class_Cc), number_class_Cc, mout_Cc$snpdf$ell1)/rowSums(table(names(number_class_Cc), number_class_Cc))*100)

df_number_Cc <- data.frame(table(names(number_class_Cc), number_class_Cc), Reference = "Cc"); head(df_number_Cc)
df_number_Ce <- data.frame(table(names(number_class_Ce), number_class_Ce), Reference = "Ce"); head(df_number_Ce)
colnames(df_number_Cc) <- colnames(df_number_Ce) <- c("Chromosome", "N.class", "Frequency", "Reference")
df_number <- rbind(df_number_Cc, df_number_Ce)
df_number$Chromosome <- factor(df_number$Chromosome, levels = c(1:11), ordered = TRUE)
df_number$N.class <- as.integer(df_number$N.class)
head(df_number)

ggplot(df_number, aes(x=Reference, y = Frequency, alpha= N.class, fill = Reference)) + 
  facet_grid(~ Chromosome) +
  geom_bar(position="fill", stat="identity") +
  scale_y_continuous(labels = function(x) x*100, expand = c(0,0)) +
  scale_fill_manual(values = c("#993300", "#f5ad05")) +
  labs(y = "Frequency (%)", alpha = "Number of\nclasses") +
  theme_classic() +
  theme(strip.background = element_blank())
ggsave("counts.png", width = 7, height = 4, dpi = 400)

table(unlist(lapply(class_Cc[which(number_class_Cc == 1)], names)))
table(unlist(lapply(class_Ce[which(number_class_Ce == 1)], names)))

snp_Cc <- snp_Cc[-which(number_class_Cc == 1),]; dim(snp_Cc)
snp_Ce <- snp_Ce[-which(number_class_Ce == 1),]; dim(snp_Ce)

number_class_Cc <- number_class_Cc[-which(number_class_Cc == 1)]; length(number_class_Cc)
number_class_Ce <- number_class_Ce[-which(number_class_Ce == 1)]; length(number_class_Ce)
```

Write some filtering functions:

```{r}
count.na <- function(x) {table(is.na(x))["TRUE"]}
count.A <- function(x, ploidy = 4) {sum(table(x)*as.numeric(names(table(x)))) / (sum(table(x))*ploidy)}
count.class <- function(x) {tail(sort(table(x)), 1) / sum(table(x))}
marker.callrate <- function(snp, max.mis = 0.25) {
  z <- apply(snp, 2, count.na)
  z[is.na(z)] <- 0
  z <- z / nrow(snp)
  return(which(z >= max.mis))
}
ind.callrate <- function(snp, max.mis = 0.25) {
  z <- apply(snp, 1, count.na)
  z[is.na(z)] <- 0
  z <- z / ncol(snp)
  return(which(z >= max.mis))
}
allele.freq <- function(snp, min.maf = 0.25) {
  z <- apply(snp, 2, count.A)
  return(which(z > 1-min.maf | z < min.maf))
}
class.freq <- function(snp, max.class = 0.75) { # 
  z <- apply(snp, 2, count.class)
  return(which(z > max.class))
}
monomorphic <- function(snp) {
  z <- apply(snp, 2, count.class)
  return(which(z == 1))
}
```

```{r}
load("snp_Cc.rda"); dim(snp_Cc)
vcf_Cc <- read.vcfR("Cc_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = TRUE)
GTmat_Cc2 <- extract.gt(vcf_Cc, element = "GT", as.numeric = FALSE); GTmat_Cc2[1:10,1:5]; dim(GTmat_Cc2)
dim(GTmat_Cc2)
GTmat_Cc2 <- GTmat_Cc2[which(rownames(GTmat_Cc2) %in% rownames(snp_Cc)),which(colnames(GTmat_Cc2) %in% colnames(snp_Cc))]; dim(GTmat_Cc2)

snp_Cc <- snp_Cc[which(rownames(snp_Cc) %in% rownames(GTmat_Cc2)),which(colnames(snp_Cc) %in% colnames(GTmat_Cc2))]; dim(snp_Cc)
```


```{r, cache=FALSE}
map_Cc <- data.frame(SNPID = rownames(snp_Cc), matrix(unlist(strsplit(rownames(snp_Cc), split = "_")), ncol = 2, byrow = TRUE, dimnames = list(NULL, c("CHR", "POS")))); dim(map_Cc); head(map_Cc)
map_Cc$CHR <- gsub("chr", "", map_Cc$CHR)
map_Cc$CHR <- gsub("c", "", map_Cc$CHR)
map_Cc$CHR <- factor(map_Cc$CHR, levels = unique(map_Cc$CHR))
map_Cc$POS <- as.integer(map_Cc$POS)
map_Cc2 <- map_Ccud <- map_Ccst <- map_Cc
head(map_Cc)
```

```{r}
library(segtest)
load("mout_Cc.rda")
glist <- multidog_to_g(mout = mout_Cc, type = "off_gl", ploidy = 4) # gl = genotype + likelihood
str(glist)
rm(mout_Cc); gc()
```

```{r}
lrt_ces <- seg_multi(g = glist$g, p1 = glist$p1, p1_ploidy = 4, model = "seg", outlier = TRUE, ret_out = TRUE, db = "ces")
lrt_prcs <- seg_multi(g = glist$g, p1 = glist$p1, p1_ploidy = 4, model = "seg", outlier = TRUE, ret_out = TRUE, db = "prcs")
save(lrt_ces, lrt_prcs, file = "lrt.rda")
```

```{r}
load("lrt.rda")
lrt1 <- data.frame(SNPID = lrt_ces$snp, do.call(cbind, lrt_ces[1:8])); dim(lrt1); head(lrt1)
```

```{r, cache=FALSE, warning=FALSE}
snp_Cc <- t(snp_Cc)
map_Ccud$`4` <- map_Ccud$`3` <- map_Ccud$`2` <- map_Ccud$`1` <- map_Ccud$`0` <- 0
map_Ccud$`1:8:18:8:1` <- map_Ccud$`1:4:6:4:1` <- map_Ccud$`1:2:1` <- NA
head(map_Ccud)
for(m in 1:ncol(snp_Cc)) {
  count <- table(snp_Cc[,m])
  map_Ccud[m,names(count)] <- count
  class <- sort(names(tail(sort(unlist(map_Ccud[m,c("0","1","2","3","4")])), 3)))
  map_Ccud[m,"1:2:1"] <- chisq.test(unlist(map_Ccud[m,class]), p = c(1,2,1)/4)$p.value
  map_Ccud[m,"1:4:6:4:1"] <- chisq.test(unlist(map_Ccud[m,c("0","1","2","3","4")]), p = c(1,4,6,4,1)/16)$p.value
  map_Ccud[m,"1:8:18:8:1"] <- chisq.test(unlist(map_Ccud[m,c("0","1","2","3","4")]), p = c(1,8,18,8,1)/36)$p.value
}
head(map_Ccud)
```

```{r, cache=FALSE}
GTmat_Cc2 <- t(GTmat_Cc2)
map_Cc2$`1/1` <- map_Cc2$`0/1` <- map_Cc2$`0/0` <- 0
map_Cc2$`1:2:1` <- NA
head(map_Cc2)
for(m in 1:ncol(GTmat_Cc2)) {
  count <- table(GTmat_Cc2[,m])
  map_Cc2[m,names(count)] <- count
  class <- sort(names(sort(unlist(map_Cc2[m,c("0/0","0/1","1/1")]))))
  map_Cc2[m,"1:2:1"] <- chisq.test(unlist(map_Cc2[m,class]), p = c(1,2,1)/4)$p.value
}
head(map_Cc2)
```


Plotting $\chi^2$ tests across chromosomes:

```{r, cache=FALSE, warning=FALSE}
chisq_map <- function(map, cols) {
  df_map <- map %>% pivot_longer(cols = cols); head(df_map)
  A <- ggplot(df_map) +
    geom_point(aes(x = POS/1e6, y = -log10(value), color = name), shape = 1, size = 0.5, alpha = 0.5) +
    geom_abline(intercept = -log10(0.05/nrow(map)), slope = 0, linewidth = 0.2, linetype = "dashed") +
    facet_grid(~ CHR, scales = "free_x", space = "free_x") + 
    scale_y_continuous(expand = c(0,0)) +
    scale_x_continuous(breaks = seq(0,80,20)) +
    labs(y = expression(-"log"[10](italic("P"))), x = "Position (Mb)", color = "Segregation") +
    theme_classic() + 
    theme(legend.position = "bottom", strip.background = element_blank(), axis.title.x = element_blank(), axis.text.x = element_blank()); A
  B <- ggplot(df_map) +
    geom_point(aes(x = POS/1e6, y = -log10(value), color = name), shape = 1, size = 0.5, alpha = 0.5) +
    geom_abline(intercept = -log10(0.05/nrow(map)), slope = 0, linewidth = 0.2, linetype = "dashed") +
    facet_grid(~ CHR, scales = "free_x", space = "free_x") + 
    scale_y_continuous(expand = c(0,0), limits = c(0,9.9)) +
    scale_x_continuous(breaks = seq(0,80,20)) +
    labs(y = expression(-"log"[10](italic("P"))), x = "Position (Mb)", color = "Segregation") +
    theme_classic() + 
    theme(legend.position = "bottom", strip.background = element_blank(), strip.text = element_blank(), axis.title.y = element_text(margin = margin(t = 0, r = 5.25, b = 0, l = 0))); B
  ggarrange(A, B, ncol = 1, heights = c(5,2.5), common.legend = TRUE, legend = "bottom", labels = letters[1:2])
}
```

```{r, cache=FALSE, warning=FALSE}
map_Ccst <- left_join(map_Ccst, lrt1, by = "SNPID"); head(map_Ccst); dim(map_Ccst)
chisq_map(map = map_Ccst, cols = 6)
chisq_map(map = map_Ccud, cols = 9:11)
chisq_map(map = map_Cc2, cols = 7)
#chisq_map(map = map_Cc4, cols = 9:11)
```
```{r}
library(dplyr)

# Comece com o dataframe do updog, que tem a maioria das informações
# Selecione as colunas de identificação e os p-valores tetraploides
map_Cc_all_tests <- map_Ccud %>%
  select(
    SNPID, CHR, POS,
    p_val_diploide     = `1:2:1`,
    p_val_tetra_sem_dr = `1:4:6:4:1`,
    p_val_tetra_com_dr = `1:8:18:8:1`
  )
```


```{r}

dim(map_Ccud)
map_Ccud <- map_Ccud %>% 
  filter(`0` < 211.85, `2` < 211.85, `4` < 211.85); dim(map_Ccud)
map_Ccud <- map_Ccud[,c(1:3,9)]
map_Ccud$name <- "updog"
table(map_Ccud$`1:2:1` > (0.05/nrow(map_Ccud)))

dim(map_Cc2)
map_Cc2 <- map_Cc2 %>% 
  filter(`0/0` < 211.85, `0/1` < 211.85, `1/1` < 211.85); dim(map_Cc2)
map_Cc2 <- map_Cc2[,c(1:3,7)]
map_Cc2$name <- "FreeBayes 2x"
table(map_Cc2$`1:2:1` > (0.05/nrow(map_Cc2)))


map_Ccst <- map_Ccst[,c(1:3,6)]
map_Ccst$name <- "updog+segtest"
colnames(map_Ccst)[4] <- "1:2:1"
head(map_Ccst)

table(map_Ccst$`1:2:1` > (0.05/nrow(map_Ccst)))


map_Cc_all <- rbind(map_Cc2, map_Ccud, map_Ccst)
head(map_Cc_all)


map_Cc_all <- map_Cc_all %>% 
  group_by(name) %>% 
  arrange(desc(`1:2:1`)) %>% 
  mutate(y = 1:n())


bonferroni <- map_Cc_all %>% 
  group_by(name) %>% 
  summarise(counts = n())

distorted <- map_Cc_all %>% 
  group_by(name) %>% 
  summarise(dist0 = sum(`1:2:1` < (0.05/n())), 
            dist = sum(`1:2:1` < (0.05/n()))/n()*100, 
            x = n(), y = min(`1:2:1`))


library(grafify)
library(ggplot2)

ggplot() +
  geom_point(data = map_Cc_all, aes(x = -log10(`1:2:1`), 
                                    y = y, group = name, 
                                    color = name), shape = 1) +
  geom_vline(data = bonferroni, aes(xintercept = -log10(0.05/counts), 
                                    group = name, 
                                    color = name), 
             linewidth = 0.2, 
             linetype = "dashed") +
  ggrepel::geom_text_repel(data = distorted, 
                           aes(y = x, x = -log10(y), 
                               label = paste0(round(dist, 1),"%"), 
                               color = name), 
                           size = 3.5, max.overlaps = 100, seed = 123, 
                           min.segment.length = 0, nudge_y = 1, 
                           show.legend = FALSE) +
  scale_colour_grafify() +
  labs(x = expression(-"log"[10](italic("P"))), 
       y = "Number of SNPs", 
       color = "Caller") +
  theme_classic()

ggsave("chisq_3_callers.png", width = 6, height = 4, dpi = 400)
```

```{r}
# --- FASE 1: FILTRAGEM CORRETA E ROBUSTA ---

# Defina o limiar de Bonferroni uma única vez para clareza
bonferroni_threshold <- 0.05 / nrow(map_Cc)

# Crie um dataframe 'df_seg' contendo TODOS os SNPs que passam
# em PELO MENOS UM dos três testes.
# O operador "|" significa "OU".
df_seg <- map_Cc %>%
  dplyr::filter(`1:2:1` > bonferroni_threshold | 
                `1:4:6:4:1` > bonferroni_threshold | 
                `1:8:18:8:1` > bonferroni_threshold)

cat("Número total de marcadores segregantes válidos:", nrow(df_seg), "\n")


# --- FASE 2: CLASSIFICAÇÃO E PREPARAÇÃO PARA O GRÁFICO ---

# Defina os nomes das colunas de segregação. Isso evita usar "números mágicos" como 9:11.
seg_cols <- c("1:2:1", "1:4:6:4:1", "1:8:18:8:1")

# Classifique cada SNP baseado no teste com o MAIOR p-value (melhor ajuste).
df_seg <- df_seg %>%
  dplyr::mutate(Segregation = seg_cols[apply(.[, seg_cols], 1, which.max)])


# Crie a tabela de resumo de forma mais clara usando dplyr::count
# Isso já nomeia as colunas corretamente (em vez de Var1, Var2).
summary_df <- df_seg %>%
  dplyr::count(CHR, Segregation, name = "Freq")


# --- FASE 3: VISUALIZAÇÃO ---

# O código do ggplot agora usa nomes de colunas claros (CHR, Freq, Segregation)
ggplot(summary_df, aes(x = CHR, y = Freq, fill = Segregation)) + 
  geom_bar(position="fill", stat="identity") +
  scale_y_continuous(labels = scales::percent, expand = c(0,0)) + # scales::percent é um atalho útil
  labs(y = "Frequency (%)", 
       x = "Chromosome", 
       fill = "Segregation Pattern") +
  theme_classic() +
  theme(strip.background = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1)) # Melhora a leitura dos eixos

# Salva o gráfico
ggsave("segr_corrected.png", width = 7, height = 4, dpi = 400)
```
