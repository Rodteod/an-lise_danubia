---
title: "Untitled"
author: "Rodrigo"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r, cache=FALSE, message=FALSE, warning=FALSE, results='hide'}

if (!require("pacman")) install.packages("pacman")

pacotes_cran <- c(
  "devtools",
  "tidyverse",    # Coleção de pacotes para manipulação e visualização de dados (ggplot2, dplyr, etc.)
  "vcfR",         # Para ler e manipular arquivos VCF (seus dados genéticos)
  "CMplot",       # Para criar gráficos de Manhattan e outros gráficos genômicos
  "parallel",     # Para executar tarefas em paralelo e acelerar o processamento
  "ggpubr",       # Facilita a criação de gráficos prontos para publicação
  "ggh4x",        # Extensões para o ggplot2
  "grid",          # Funções gráficas de baixo nível
  "circlize",
  "onemap"
)
# formato "nome_do_usuario/nome_do_repositorio".
pacotes_github <- c(
  "dcgerard/segtest@higher", # Pacote para testes de segregação. A parte "@higher" instala uma versão específica.
  "dcgerard/updog",          # Para genotipagem de poliploides
  "dcgerard/ldsep",          # Para análise de desequilíbrio de ligação
  "jendelman/GWASpoly",      # Para estudos de associação genômica ampla (GWAS) em poliploides
  "mmollina/mappoly"         # Para construção de mapas de ligação em poliploides
)

pacman::p_load(char = pacotes_cran)
pacman::p_load_gh(char = pacotes_github)

rm(list = ls())
gc(verbose = FALSE)
```

```{r, cache=FALSE}

library(vcfR)
library(ape)
library(stringr)
library(ggplot2)

# Carregar os arquivos
vcf_Cc <- vcfR::read.vcfR("Cc_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf")
gff <- ape::read.gff("genomic.gff")
dna <- ape::read.dna("GCF_036785885.1_Coffea_Arabica_ET-39_HiFi_genomic.fna", format = "fasta")

# Criar a tabela de mapeamento
region_info <- gff[gff$type == "region", ]
bio_names <- sapply(as.character(region_info$attributes), function(attr_string) {
  fields <- strsplit(attr_string, ";")[[1]]
  chrom_field <- grep("chromosome=", fields, value = TRUE)
  if (length(chrom_field) == 0) return(NA)
  return(strsplit(chrom_field, "=")[[1]][2])
})
chrom_map <- data.frame(
  ncbi_id = as.character(region_info$seqid),
  bio_name = bio_names
)
chrom_map <- chrom_map[chrom_map$bio_name != "Unknown", ]
chrom_map <- na.omit(chrom_map)
```


```{r, cache=FALSE}
# Padronizar GFF: Substituir 'NC_...' por '1c', '1e', etc.
gff_chroms <- as.character(gff$seqid)
gff$seqid <- chrom_map$bio_name[match(gff_chroms, chrom_map$ncbi_id)]

# Padronizar DNA: Substituir 'NC_...' por '1c', '1e', etc.
dna_ids <- word(names(dna), 1) 
names(dna) <- chrom_map$bio_name[match(dna_ids, chrom_map$ncbi_id)]

# Padronizar VCF: Remover o prefixo 'chr' para ter '1c', '1e', etc.
vcf_Cc@fix[, 'CHROM'] <- gsub("chr", "", getCHROM(vcf_Cc))

# Remover qualquer elemento que não foi padronizado (virou NA)
gff <- gff[!is.na(gff$seqid), ]
dna <- dna[!is.na(names(dna))]
vcf_Cc <- vcf_Cc[!is.na(getCHROM(vcf_Cc)), ]

print("Nomes padronizados. Verificando o número de variantes restantes no VCF:")
print(nrow(vcf_Cc@fix))


# Selecionar a sequência de DNA para o cromossomo '1c'
dna_1c <- dna[names(dna) == '1c']

# Criar o objeto.
chrom <- create.chromR(name = '1c', vcf = vcf_Cc, seq = dna_1c, ann = gff)
png(filename = "grafico_qc_cromossomo_1c.png", width = 800, height = 1000)

# 2. Executa o comando para criar o gráfico.
chromoqc(chrom, dp.alpha = 50)

# 3. CRUCIAL: Fecha o dispositivo. Isso finaliza e salva o arquivo no seu computador.
dev.off()

# Gerar a visualização de controle de qualidade
print("Objeto chromR criado com sucesso! Gerando o gráfico...")
chromoqc(chrom, dp.alpha = 50)
```

```{r, cache=FALSE}
# ler arquivos vcf

vcf_Ca <- read.vcfR("Ca_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = TRUE)
vcf_Cc <- read.vcfR("Cc_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = TRUE)
vcf_Ce <- read.vcfR("Ce_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = TRUE)

#extrair contagem de reads do alelo alternativo
AOmat_Ca <- extract.gt(vcf_Ca, element = "AO", as.numeric = TRUE)
AOmat_Cc <- extract.gt(vcf_Cc, element = "AO", as.numeric = TRUE)
AOmat_Ce <- extract.gt(vcf_Ce, element = "AO", as.numeric = TRUE)

#extrair profundidade

DPmat_Ca <- extract.gt(vcf_Ca, element = "DP", as.numeric = TRUE)
DPmat_Cc <- extract.gt(vcf_Cc, element = "DP", as.numeric = TRUE)
DPmat_Ce <- extract.gt(vcf_Ce, element = "DP", as.numeric = TRUE)

#Verificação
AOmat_Ca[1:10,1:5]

rm(vcf_Ca, vcf_Ce, vcf_Cc); gc(verbose = FALSE)
```
```{r, cache=FALSE}
counts_Ca <- table(matrix(unlist(strsplit(rownames(AOmat_Ca), split = "_")), ncol = 2, byrow = TRUE)[,1])
counts_Cc <- table(matrix(unlist(strsplit(rownames(AOmat_Cc), split = "_")), ncol = 2, byrow = TRUE)[,1])
counts_Ce <- table(matrix(unlist(strsplit(rownames(AOmat_Ce), split = "_")), ncol = 2, byrow = TRUE)[,1])

#converte em dataframe
counts_Ca <- data.frame(Reference=rep("Ca", length(counts_Ca)), counts_Ca)
counts_Ce <- data.frame(Reference=rep("Ce", length(counts_Ce)), counts_Ce)
counts_Ca <- data.frame(Reference=rep("Cc", length(counts_Cc)), counts_Cc)

# juntar os data frames

counts2x <- rbind(counts_Ca, counts_Ce, counts_Cc)

if (!require("stringr")) install.packages("stringr")
library(stringr)
counts2x$Chr <- as.integer(str_extract(counts2x$Var1, "\\d+")) # Extrai o número do cromossomo
counts2x$Subgenome <- ifelse(grepl("c", counts2x$Var1, ignore.case = TRUE) & grepl("Cc", counts2x$Reference), "canephora",
                           ifelse(grepl("e", counts2x$Var1, ignore.case = TRUE) & grepl("Ce", counts2x$Reference), "eugenioides", "arabica"))
library(ggplot2)

# Filtrar o dataframe, coluna 'Chr' NÃO é NA.
counts2x_filtered <- counts2x[!is.na(counts2x$Chr), ]


B <- ggplot(counts2x_filtered, aes(x = as.factor(Chr), y = Freq, fill = Reference)) +
  geom_bar(stat="identity", position = position_dodge(), alpha = 0.8) +
  scale_fill_manual(values = c("Cc" = "#993300", "Ce" = "#f5ad05"),
                    labels = c("Ref. Canephora", "Ref. Eugenioides")) +
  labs(x = "Cromossomo", y = "Número de SNPs", fill = "Alinhamento de Referência") +
  theme_classic() +
  theme(axis.text = element_text(size = 10),
        axis.title = element_text(size = 12, face = "bold"),
        legend.position = "top");

# Exibir o novo gráfico
print(B)

# Salvar o novo gráfico
ggsave("contagem_snps_por_cromossomo_v2.png", plot = B, width = 10, height = 6, dpi = 400)
```

```{r, cache=FALSE}
vcf_Cc <- read.vcfR("Cc_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = TRUE)
vcf_Ce <- read.vcfR("Ce_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = TRUE)
vcf_Ca <- read.vcfR("Ca_var_norm_filter_BIAL_QUAL_AF_NS_flex.vcf", verbose = TRUE)

GTmat_Cc4 <- extract.gt(vcf_Cc, element = "GT", as.numeric = FALSE); GTmat_Cc4[1:10,1:5]; dim(GTmat_Cc4); table(GTmat_Cc4)

AOmat_Ca <- extract.gt(vcf_Ca, element = "AO", as.numeric = TRUE)
AOmat_Cc <- extract.gt(vcf_Cc, element = "AO", as.numeric = TRUE)
AOmat_Ce <- extract.gt(vcf_Ce, element = "AO", as.numeric = TRUE)
DPmat_Ca <- extract.gt(vcf_Ca, element = "DP", as.numeric = TRUE)
DPmat_Cc <- extract.gt(vcf_Cc, element = "DP", as.numeric = TRUE)
DPmat_Ce <- extract.gt(vcf_Ce, element = "DP", as.numeric = TRUE)

rm(vcf_Ca, vcf_Cc, vcf_Ce); gc(verbose = FALSE)

```
```{r, cache=FALSE}
dim(DPmat_Ca)
dim(DPmat_Cc)
dim(DPmat_Ce)
hist(DPmat_Ca, breaks = 300)
hist(DPmat_Ce, breaks = 300)
hist(DPmat_Cc, breaks = 300)

widemat_Ca <- data.frame(SNP=rownames(DPmat_Ca), Reference = "Ca", DPmat_Ca)
widemat_Ce <- data.frame(SNP=rownames(DPmat_Ce), Reference = "Ce", DPmat_Ce)
widemat_Cc <- data.frame(SNP=rownames(DPmat_Cc), Reference = "Cc", DPmat_Cc)

longmat_Ca <- tidyr::pivot_longer(as.data.frame(widemat_Ca), cols = -c(1:2), names_to = "Amostra", values_to = "DP")
longmat_Ce <- tidyr::pivot_longer(as.data.frame(widemat_Ce), cols = -c(1:2), names_to = "Amostra", values_to = "DP")
longmat_Cc <- tidyr::pivot_longer(as.data.frame(widemat_Cc), cols = -c(1:2), names_to = "Amostra", values_to = "DP")

longmat <- rbind(longmat_Cc, longmat_Ce, longmat_Ca)
```
```{r, cache=FALSE}
A <- ggplot(longmat) +
  geom_histogram(aes(x = DP, fill = Reference), position = "identity", bins = 200, alpha = 0.7) +
  facet_grid(Reference ~ ., scales = "free_y") + # Painéis separados para cada referência
  scale_fill_manual(values = c("Ca" = "grey", "Cc" = "#993300", "Ce" = "#f5ad05")) +
 # scale_x_continuous(limits = c(0, 200), expand = c(0,0)) + # Focando em profundidades de 0 a 200
  labs(x = "Profundidade de Leitura (DP)", y = "Frequência") +
  theme_classic()


B <- ggplot(longmat) +
  geom_boxplot(aes(y = Reference, x = DP, fill = Reference)) +
  scale_fill_manual(values = c("Ca" = "grey", "Cc" = "#993300", "Ce" = "#f5ad05")) +
  #scale_x_continuous(limits = c(0, 200), expand = c(0,0)) +
  labs(x = "Profundidade de Leitura (DP)", y = "") +
  theme_classic() +
  theme(legend.position = "none")

# Combinando os dois gráficos em uma única figura
cowplot::plot_grid(B, A, ncol = 1, rel_heights = c(0.7, 2), align = 'v', axis = 'lr')
ggsave("distribuicao_profundidade_leitura.png", width = 8, height = 6, dpi = 300)


tapply(longmat$DP, longmat$Reference, median, na.rm = TRUE)
```
```{r, cache=FALSE}

# contagem de reads do alelo referencia 
ROmat_Cc <- DPmat_Cc - AOmat_Cc
ROmat_Ce <- DPmat_Ce - DPmat_Ce
ROmat_Ca <- DPmat_Ca - DPmat_Ca


#calculo de cobertura para cada genótipo
ROmat2_Cc <- ROmat_Cc^2
ROmat2_Ce <- ROmat_Ce^2
ROmat2_Ca <- ROmat_Ca^2
AOmat2_Cc <- AOmat_Cc^2
AOmat2_Ce <- AOmat_Ce^2
AOmat2_Ca <- AOmat_Ca^2

SQmat_Cc <- sqrt(AOmat2_Cc + ROmat2_Cc)
SQmat_Ce <- sqrt(AOmat2_Ce + ROmat2_Ce)
SQmat_Ca <- sqrt(AOmat2_Ca + ROmat2_Ca)

# -- Para o alinhamento Canephora (Cc) --
cat("\nIniciando filtro adaptativo para Cc...\n")
# Checando o número de NAs ANTES do filtro.
cat("NAs em DPmat_Cc ANTES:", sum(is.na(DPmat_Cc)), "\n")

for (m in 1:nrow(DPmat_Cc)) {
  median_coverage <- median(SQmat_Cc[m,], na.rm = TRUE)
  exclude <- which(SQmat_Cc[m,] < (0.10* median_coverage)) 
  DPmat_Cc[m, exclude] <- NA
  AOmat_Cc[m, exclude] <- NA
}

cat("NAs em DPmat_Cc DEPOIS:", sum(is.na(DPmat_Cc)), "\n")

for (m in 1:nrow(DPmat_Ce)) {
  media_coverage <- median(SQmat_Ce[m,], na.rm = TRUE)
  exclude <- which(SQmat_Ce[m,] < (0.10*media_coverage))
  DPmat_Ce[m, exclude] <- NA
  AOmat_Ce[m, exclude] <- NA
}

for (m in 1:nrow(DPmat_Ca)) {
  media_coverage <- median(SQmat_Ca[m,], na.rm = TRUE)
  exclude <- which(SQmat_Ca[m,] < (0.10*media_coverage))
  DPmat_Ca[m, exclude] <- NA
  AOmat_Ca[m, exclude] <- NA
}

rm(ROmat_Cc, ROmat2_Cc, AOmat2_Cc, SQmat_Cc); gc(verbose = FALSE)
rm(ROmat_Ce, ROmat2_Ce, AOmat2_Ce, SQmat_Ce); gc(verbose = FALSE)
rm(ROmat_Ca, ROmat2_Ca, AOmat2_Ca, SQmat_Ca); gc(verbose = FALSE)

```
```{r, cache=FALSE}


count.na <- function(x) { sum(is.na(x)) }


cat("\nFiltrando indivíduos com mais de 25% de dados faltantes...\n")
# 'apply(DPmat_Cc, 2, ...)' aplica a função a cada coluna (2 = colunas).
# Conta NAs para cada indivíduo.
ind.nas_Cc <- apply(DPmat_Cc, 2, count.na)
ind.nas_Ce <- apply(DPmat_Ce, 2, count.na)
ind.nas_Ca <- apply(DPmat_Ca, 2, count.na)

# Remover individuos se tiver mais de 25% de NAs.
threshold_ind_Cc <- nrow(DPmat_Cc) * 0.25
threshold_ind_Ce <- nrow(DPmat_Ce) * 0.25
threshold_ind_Ca <- nrow(DPmat_Ca) * 0.25
ind_to_remove_Cc <- which(ind.nas_Cc > threshold_ind_Cc)
ind_to_remove_Ce <- which(ind.nas_Ce > threshold_ind_Ce)
ind_to_remove_Ca <- which(ind.nas_Ca > threshold_ind_Ca)

cat("Indivíduos a remover de Cc:", length(ind_to_remove_Cc), "\n")
cat("Indivíduos a remover de Ce:", length(ind_to_remove_Ce), "\n")
cat("Indivíduos a remover de Ca:", length(ind_to_remove_Ca), "\n")

# Se houver indivíduos para remover, removemos.
if(length(ind_to_remove_Cc) > 0) {
  AOmat_Cc <- AOmat_Cc[, -ind_to_remove_Cc]
  DPmat_Cc <- DPmat_Cc[, -ind_to_remove_Cc]
}
if(length(ind_to_remove_Ce) > 0) {
  AOmat_Ce <- AOmat_Ce[, -ind_to_remove_Ce]
  DPmat_Ce <- DPmat_Ce[, -ind_to_remove_Ce]
}

if(length(ind_to_remove_Ce) > 0) {
  AOmat_Ca <- AOmat_Ca[, -ind_to_remove_Ca]
  DPmat_Ca <- DPmat_Ca[, -ind_to_remove_Ca]
}

cat("\nFiltrando marcadores com mais de 25% de dados faltantes...\n")
# 'apply(DPmat_Cc, 1, ...)' aplica a função a cada linha (1 = linhas).
# Conta NAs para cada marcador.
mrk.nas_Cc <- apply(DPmat_Cc, 1, count.na)
mrk.nas_Ce <- apply(DPmat_Ce, 1, count.na)
mrk.nas_Ca <- apply(DPmat_Ca, 1, count.na)

# Define os marcadores a serem removidos.
threshold_mrk_Cc <- ncol(DPmat_Cc) * 0.25
threshold_mrk_Ce <- ncol(DPmat_Ce) * 0.25
threshold_mrk_Ca <- ncol(DPmat_Ca) * 0.25

mrk_to_remove_Cc <- which(mrk.nas_Cc > threshold_mrk_Cc)
mrk_to_remove_Ce <- which(mrk.nas_Ce > threshold_mrk_Ce)
mrk_to_remove_Ca <- which(mrk.nas_Ca > threshold_mrk_Ca)

cat("Marcadores a remover de Cc:", length(mrk_to_remove_Cc), "\n")
cat("Marcadores a remover de Ce:", length(mrk_to_remove_Ce), "\n")
cat("Marcadores a remover de Ca:", length(mrk_to_remove_Ca), "\n")

# Remove as linhas (marcadores) identificadas.
if(length(mrk_to_remove_Cc) > 0) {
  AOmat_Cc <- AOmat_Cc[-mrk_to_remove_Cc, ]
  DPmat_Cc <- DPmat_Cc[-mrk_to_remove_Cc, ]
}
if(length(mrk_to_remove_Ce) > 0) {
  AOmat_Ce <- AOmat_Ce[-mrk_to_remove_Ce, ]
  DPmat_Ce <- DPmat_Ce[-mrk_to_remove_Ce, ]
}

if(length(mrk_to_remove_Ca) > 0) {
  AOmat_Ca <- AOmat_Ca[-mrk_to_remove_Ca, ]
  DPmat_Ca <- DPmat_Ca[-mrk_to_remove_Ca, ]
}

cat("\nDimensões finais das matrizes:\n")
cat("AOmat_Cc:", dim(AOmat_Cc), "\n")
cat("DPmat_Cc:", dim(DPmat_Cc), "\n")
cat("AOmat_Ce:", dim(AOmat_Ce), "\n")
cat("DPmat_Ce:", dim(DPmat_Ce), "\n")
cat("AOmat_Ca:", dim(AOmat_Ca), "\n")
cat("DPmat_Ca:", dim(DPmat_Ca), "\n")

# Salva as matrizes limpas em arquivos para uso futuro.
save(AOmat_Cc, DPmat_Cc, file = "matrizes_filtradas_Cc.rda")
save(AOmat_Ce, DPmat_Ce, file = "matrizes_filtradas_Ce.rda")
save(AOmat_Ca, DPmat_Ca, file = "matrizes_filtradas_Ca.rda")



```

```{r,cache=FALSE}

library(updog)

nc <- parallel::detectCores() - 1
cat("Usando", nc, "núcleos para o processamento.\n")



cat("\nCarregando dados filtrados de Cc e iniciando updog...\n")
load("matrizes_filtradas_Cc.rda")
cat("Dimensões dos dados de entrada (SNPs x Amostras):", dim(AOmat_Cc), "\n")


mout_Cc <- multidog(refmat = AOmat_Cc, 
                    sizemat = DPmat_Cc, 
                    ploidy = 4, 
                    model = "s1pp", 
                    nc = nc)

cat("Análise de Cc concluída. Salvando resultados...\n")
save(mout_Cc, file="mout_Cc.rda")
# Limpa a memória antes de começar o próximo.
rm(mout_Cc, AOmat_Cc, DPmat_Cc); gc(verbose = FALSE)
cat("Resultados de Cc salvos em 'mout_Cc.rda'.\n")


# alinhamento Eugenioides (Ce) 
cat("\nCarregando dados filtrados de Ce e iniciando updog...\n")
load("matrizes_filtradas_Ce.rda")
cat("Dimensões dos dados de entrada (SNPs x Amostras):", dim(AOmat_Ce), "\n")


mout_Ce <- multidog(refmat = AOmat_Ce, 
                    sizemat = DPmat_Ce, 
                    ploidy = 4, 
                    model = "s1pp", 
                    nc = nc)

cat("Análise de Ce concluída. Salvando resultados...\n")
save(mout_Ce, file="mout_Ce.rda")
rm(mout_Ce, AOmat_Ce, DPmat_Ce); gc(verbose = FALSE)
cat("Resultados de Ce salvos em 'mout_Ce.rda'.\n")
```


```{r, cache=FALSE}
library(updog)

nc <- parallel::detectCores() - 1
cat("Usando", nc, "núcleos para o processamento.\n")



cat("\nCarregando dados filtrados de Cc e iniciando updog...\n")
load("matrizes_filtradas_Ca.rda")
cat("Dimensões dos dados de entrada (SNPs x Amostras):", dim(AOmat_Ca), "\n")

# Executa o modelo multidog.
mout_Ca <- multidog(refmat = AOmat_Ca, 
                    sizemat = DPmat_Ca, 
                    ploidy = 4, 
                    model = "s1pp", 
                    nc = nc)
cat("Análise de Ca concluída. Salvando resultados...\n")
save(mout_Ca, file="mout_Ca.rda")
rm(mout_Ca, AOmat_Ca, DPmat_Ca); gc(verbose = FALSE)
cat("Resultados de Ce salvos em 'mout_Ce.rda'.\n")
```

```{r, eval=FALSE}
library(updog)

load("mout_Cc.rda")
nmrk <- length(mout_Cc$snpdf$snp)
indices <- split(1:nmrk, ceiling(1:nmrk/100))
dir.create(path = "plots_Cc", showWarnings = FALSE)
for(i in 1:length(indices)) {
  pdf(paste0("plots_Cc/mout_Cc_",i,".pdf"), width = 6, height = 5)
  print(plot(mout_Cc, indices=indices[[i]]))
  dev.off()
}

load("mout_Ce.rda")
nmrk <- length(mout_Ce$snpdf$snp)
indices <- split(1:nmrk, ceiling(1:nmrk/100))
dir.create(path = "plots_Ce", showWarnings = FALSE)
for(i in 1:length(indices)) {
  pdf(paste0("plots_Ce/mout_Ce_",i,".pdf"), width = 6, height = 5)
  print(plot(mout_Ce, indices=indices[[i]]))
  dev.off()
}

load("mout_Ca.rda")
nmrk <- length(mout_Ca$snpdf$snp)
indices <- split(1:nmrk, ceiling(1:nmrk/100))#Lista: cada elemento em um vetor com 100 SNPs
dir.create(path = "plots_Ca", showWarnings = FALSE) #cria uma pasta
for(i in 1:length(indices)) {
  pdf(paste0("plots_Ca/mout_Ca_",i,".pdf"), width = 6, height = 5)
  print(plot(mout_Ca, indices=indices[[i]]))
  dev.off()
}
```



```{r}

```

```{r}


```

```{r}

```
